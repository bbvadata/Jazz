/* Jazz (c) 2018-2021 kaalam.ai (The Authors of Jazz), using (under the same license):

	1. Biomodelling - The AATBlockQueue class (c) Jacques Basaldúa, 2009-2012 licensed
	  exclusively for the use in the Jazz server software.

	  Copyright 2009-2012 Jacques Basaldúa

	2. BBVA - Jazz: A lightweight analytical web server for data-driven applications.

      Copyright 2016-2017 Banco Bilbao Vizcaya Argentaria, S.A.

      This product includes software developed at

      BBVA (https://www.bbva.com/)

	3. LMDB, Copyright 2011-2017 Howard Chu, Symas Corp. All rights reserved.

	  Licensed under http://www.OpenLDAP.org/license.html


	  Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	  http://www.apache.org/licenses/LICENSE-2.0

	  Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/


using namespace jazz_elements;


// Utils
// -----

bool compare_to_tensor(pTransaction &p_txn, pTransaction &p_txo) {
	REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);

	REQUIRE((p_txo->p_block->cell_type & 0xff) <= 8);

	REQUIRE(p_txn->p_block->size == p_txo->p_block->size*(p_txo->p_block->cell_type & 0xff));

	for (int i = 0; i < p_txn->p_block->size; i++)
		if (p_txn->p_block->tensor.cell_byte[i] != p_txo->p_block->tensor.cell_byte[i])
			return false;

	return true;
}

bool compare_to_block(pTransaction &p_txn, pTransaction &p_txo) {
	REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);

	REQUIRE(p_txn->p_block->size == p_txo->p_block->total_bytes);

	uint8_t *p_bl = (uint8_t *) p_txo->p_block;

	for (int i = 0; i < p_txn->p_block->size; i++)
		if (p_txn->p_block->tensor.cell_byte[i] != p_bl[i])
			return false;

	return true;
}

// Tests
// -----

SCENARIO("Basics tests") {

	REQUIRE(TenBitsAtAddress("0-mq") == BASE_0_MQ_10BIT);
	REQUIRE(TenBitsAtAddress("bash") == BASE_BASH_10BIT);
	REQUIRE(TenBitsAtAddress("file") == BASE_FILE_10BIT);
	REQUIRE(TenBitsAtAddress("http") == BASE_HTTP_10BIT);
}


SCENARIO("Testing bash end-to-end") {

	REQUIRE(CHN.start() == SERVICE_NO_ERROR);

	REQUIRE(CHN.max_transactions > 0);
	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.warn_alloc_bytes > 0);
	REQUIRE(CHN.fail_alloc_bytes > 0);
	REQUIRE(CHN.alloc_warning_issued == false);
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN.p_free	 == CHN.p_buffer);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next == &pStoredTransaction(CHN.p_buffer)[1]);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next->p_next == &pStoredTransaction(CHN.p_buffer)[2]);
	REQUIRE(	pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 2].p_next
			== &pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1]);
	REQUIRE(pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1].p_next == nullptr);
	REQUIRE(CHN._lock_ == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	  != nullptr);
	REQUIRE(CHN.zmq_requester != nullptr);

	GIVEN("We have some blocks") {
		pTransaction p_tx_int, p_tx_inp, p_tx_res, p_tx_xlt;

		char input[] = {"for line in {0..4}; do\n"
						"  case $line in\n"
						"    0)\n"
						"      printf \"There was an Old Man in a boat, \\n\"\n"
						"	  ;;\n"
						"    1)\n"
						"      printf \"Who said: \\\"I'm afloat! I'm afloat!\\\" \\n\"\n"
						"	  ;;\n"
						"    2)\n"
						"      printf \"When they said: \\\"No, you ain't!\\\" \\n\"\n"
						"	  ;;\n"
						"    3)\n"
						"      printf \"He was ready to faint, \\n\"\n"
						"	  ;;\n"
						"    *)\n"
						"      printf \"That unhappy Old Man in a boat. \\n\"\n"
						"      ;;\n"
						"  esac\n"
						"done\n"};

		char result[] = {"There was an Old Man in a boat, \n"
						 "Who said: \"I'm afloat! I'm afloat!\" \n"
						 "When they said: \"No, you ain't!\" \n"
						 "He was ready to faint, \n"
						 "That unhappy Old Man in a boat. \n"};

		int dim[MAX_TENSOR_RANK] = {160, 0};

		REQUIRE(CHN.new_block(p_tx_int, CELL_TYPE_INTEGER, dim, FILL_NEW_WITH_ZERO) == FILL_NEW_DONT_FILL);
		p_tx_int->p_block->tensor.cell_int[0]	= 1;
		p_tx_int->p_block->tensor.cell_int[159] = 159;

		dim[0] = strlen(input) + 1;

		REQUIRE(CHN.new_block(p_tx_inp, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == FILL_NEW_DONT_FILL);

		memcpy(&p_tx_inp->p_block->tensor.cell_byte[0], input, dim[0]);

		dim[0] = strlen(result) + 100;

		REQUIRE(CHN.new_block(p_tx_res, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == FILL_NEW_DONT_FILL);

		StaticBlockHeader hea[2]	 = {0, 0};
		Name			  names[2]	 = {"input", "result"};
		pBlock			  p_block[2] = {p_tx_inp->p_block, p_tx_res->p_block};

		memcpy(&hea[0], p_block[0], sizeof(StaticBlockHeader));
		memcpy(&hea[1], p_block[1], sizeof(StaticBlockHeader));

		p_block[0]->get_dimensions(hea[0].range.dim);
		p_block[1]->get_dimensions(hea[1].range.dim);

		REQUIRE(CHN.new_block(p_tx_xlt, 2, hea, names, p_block) == SERVICE_NO_ERROR);

		pTransaction p_txn;

		WHEN("We test new_entity()/put()/get()/remove()") {
			REQUIRE(CHN.new_entity((pChar) "//bash//anything") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.new_entity((pChar) "/bash//anything") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.remove((pChar) "//bash//anything") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.remove((pChar) "/bash//anything") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.get(p_txn, (pChar) "//bash//this/that") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.get(p_txn, (pChar) "/bash//this/that") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.put((pChar) "//bash//this/that", p_tx_int->p_block) == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.put((pChar) "/bash//this/that", p_tx_int->p_block) == SERVICE_ERROR_WRONG_ARGUMENTS);
		}
		WHEN("We check all the non applicable") {
			StaticBlockHeader hea;
			Locator loc;

			REQUIRE(CHN.locate(loc, (pChar) "//bash//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/pop", (pChar) "value") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//bash//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.locate(loc, (pChar) "//bash//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/int", p_tx_int->p_block) == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//bash//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);
		}

		WHEN("We test copy") {
			REQUIRE(CHN.copy((pChar) "//bash/where", (pChar) "//bash/what") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.copy((pChar) "//bash/where", (pChar) "/bash/what") == SERVICE_ERROR_WRONG_ARGUMENTS);
		}

		WHEN("We test translate") {
			REQUIRE(CHN.translate((pTuple) p_tx_int->p_block, (pChar) "//bash/exec") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//bash/exec") == SERVICE_NO_ERROR);

			REQUIRE(p_tx_xlt->p_block->cell_type == CELL_TYPE_TUPLE_ITEM);
			REQUIRE(p_tx_xlt->p_block->size == 2);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "input") == 0);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "result") == 1);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(0)->cell_type == CELL_TYPE_BYTE);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(1)->cell_type == CELL_TYPE_BYTE);

			REQUIRE(strcmp((pChar) &pTuple(p_tx_xlt->p_block)->get_block(1)->tensor.cell_byte[0], result) == 0);
		}

		CHN.destroy_transaction(p_tx_int);
		CHN.destroy_transaction(p_tx_inp);
		CHN.destroy_transaction(p_tx_res);
		CHN.destroy_transaction(p_tx_xlt);
	}

	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	  != nullptr);
	REQUIRE(CHN.zmq_requester != nullptr);

	REQUIRE(CHN.shut_down() == SERVICE_NO_ERROR);

	REQUIRE(CHN.alloc_bytes == 0);
	REQUIRE(CHN.p_buffer == nullptr);
	REQUIRE(CHN.p_free	 == nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.curl_ok == 0);
	REQUIRE(CHN.zmq_ok	== 0);

	REQUIRE(CHN.zmq_context	  == nullptr);
	REQUIRE(CHN.zmq_requester == nullptr);
}


SCENARIO("Testing file end-to-end") {

	REQUIRE(CHN.start() == SERVICE_NO_ERROR);

	REQUIRE(CHN.max_transactions > 0);
	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.warn_alloc_bytes > 0);
	REQUIRE(CHN.fail_alloc_bytes > 0);
	REQUIRE(CHN.alloc_warning_issued == false);
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN.p_free	 == CHN.p_buffer);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next == &pStoredTransaction(CHN.p_buffer)[1]);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next->p_next == &pStoredTransaction(CHN.p_buffer)[2]);
	REQUIRE(	pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 2].p_next
			== &pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1]);
	REQUIRE(pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1].p_next == nullptr);
	REQUIRE(CHN._lock_ == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	  != nullptr);
	REQUIRE(CHN.zmq_requester != nullptr);

	GIVEN("We have some blocks and indices") {
		Index txt;

		txt["one__"] = "Abc ..";
		txt["two__"] = "[[1,2,3],%20[1,2,3]]";
		txt["three"] = "";
		txt["_four"] = "A multiline string\nis okay\n";
		txt["fi_ve"] = "UTF8 ¡what!\n\nLöwe\n";

		pTransaction p_tx_pop, p_tx_str, p_tx_chr, p_tx_int, p_tx_rea, p_tx_tim, p_tx_fil, p_tx_xlt;

		int dim[MAX_TENSOR_RANK] = {20, 5, 0};

		REQUIRE(CHN.new_block(p_tx_pop, txt) == SERVICE_NO_ERROR);
		REQUIRE(CHN.new_block(p_tx_str, CELL_TYPE_STRING, nullptr, FILL_WITH_TEXTFILE, nullptr, 0, (pChar) "Line\ntwo\nthree") == 0);
		REQUIRE(CHN.new_block(p_tx_chr, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == FILL_NEW_DONT_FILL);
		p_tx_chr->p_block->tensor.cell_byte[0]  = 1;
		p_tx_chr->p_block->tensor.cell_byte[99] = 99;

		dim[1] = 8;
		REQUIRE(CHN.new_block(p_tx_int, CELL_TYPE_INTEGER, dim, FILL_NEW_WITH_ZERO) == FILL_NEW_DONT_FILL);
		p_tx_int->p_block->tensor.cell_int[0]	= 1;
		p_tx_int->p_block->tensor.cell_int[159] = 159;

		dim[1] = 4;
		REQUIRE(CHN.new_block(p_tx_rea, CELL_TYPE_DOUBLE, dim, FILL_NEW_WITH_ZERO) == FILL_NEW_DONT_FILL);
		p_tx_rea->p_block->tensor.cell_double[0]  = 1.23;
		p_tx_rea->p_block->tensor.cell_double[79] = 21.345;

		dim[1] = 1;
		REQUIRE(CHN.new_block(p_tx_tim, CELL_TYPE_TIME, dim, FILL_NEW_DONT_FILL) == SERVICE_NO_ERROR);

		struct tm junk		= {0};
		struct tm *timeinfo = &junk;

		char buffer[20] = {"2021-08-01 12:13:14"};
		char fmt[20]	= {"%Y-%m-%d %H:%M:%S"};

		REQUIRE(strptime(buffer, fmt, timeinfo) != nullptr);

		REQUIRE(timeinfo->tm_mday == 1);

		for (int i = 0; i < 20; i++) {
			timeinfo->tm_mday =  1 + (3*i % 29);
			timeinfo->tm_hour =  7 + (5*i % 7);
			timeinfo->tm_min  = 13 + (7*i % 31);
			p_tx_tim->p_block->tensor.cell_time[i] = timegm(timeinfo);
		}

		dim[1] = 0;
		REQUIRE(CHN.new_block(p_tx_fil, CELL_TYPE_INTEGER, dim, FILL_NEW_WITH_ZERO) == FILL_NEW_DONT_FILL);
		p_tx_fil->p_block->range.filter.length = 2;
		p_tx_fil->p_block->tensor.cell_int[0]  = 0;
		p_tx_fil->p_block->tensor.cell_int[1]  = 2;

		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_tim->p_block));
		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_rea->p_block));
		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_int->p_block));
		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_chr->p_block));

		StaticBlockHeader hea[2]	 = {0, 0};
		Name			  names[2]	 = {"input", "result"};
		pBlock			  p_block[2] = {p_tx_rea->p_block, p_tx_int->p_block};

		memcpy(&hea[0], p_block[0], sizeof(StaticBlockHeader));
		memcpy(&hea[1], p_block[1], sizeof(StaticBlockHeader));

		p_block[0]->get_dimensions(hea[0].range.dim);
		p_block[1]->get_dimensions(hea[1].range.dim);

		REQUIRE(CHN.new_block(p_tx_xlt, 2, hea, names, p_block) == SERVICE_NO_ERROR);

		pTransaction p_txn;

		CHN.remove((pChar) "//file//tmp/jzz_ftest");
		CHN.new_entity((pChar) "//file//tmp/jzz_ftest");

		WHEN("We test new_entity()/remove()") {
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_NO_ERROR);

			CHN.file_lev = 1;
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 2;
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_NO_ERROR);
			CHN.file_lev = 3;
			REQUIRE(CHN.new_entity((pChar) "//files//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_IO_ERROR);
			CHN.file_lev = 2;
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 3;

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/folder/blk", p_tx_int->p_block) == SERVICE_NO_ERROR);

			THEN("We get expected structure") {
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder/blk") == SERVICE_NO_ERROR);
				REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder/blk4") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_NO_ERROR);
				REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_INDEX);
				REQUIRE(p_txn->p_hea->index["blk"] == "file");
				REQUIRE(p_txn->p_hea->index["ff"] == "folder");
				REQUIRE(p_txn->p_hea->index.size() == 2);
				CHN.destroy_transaction(p_txn);
			}

			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/blk/aaa") == SERVICE_ERROR_IO_ERROR);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/folder/blk") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_INDEX);
			CHN.destroy_transaction(p_txn);
		}
		WHEN("We test put()/get()/remove() of keys") {
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);

			REQUIRE(   CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop_t", p_tx_pop->p_block, WRITE_TENSOR_DATA)
					== SERVICE_ERROR_WRITE_FORBIDDEN);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/str_t", p_tx_str->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/chr_t", p_tx_chr->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int_t", p_tx_int->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea_t", p_tx_rea->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/tim_t", p_tx_tim->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil_t", p_tx_fil->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);

			CHN.file_lev = 1;
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 2;
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 3;
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//files//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_ERROR_WRONG_BASE);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/str", p_tx_str->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/chr", p_tx_chr->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int", p_tx_int->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea", p_tx_rea->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/tim", p_tx_tim->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil", p_tx_fil->p_block, WRITE_ONLY_IF_NOT_EXISTS) == SERVICE_NO_ERROR);

			REQUIRE(   CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil", p_tx_fil->p_block, WRITE_ONLY_IF_NOT_EXISTS)
					== SERVICE_ERROR_WRITE_FORBIDDEN);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea", p_tx_rea->p_block, WRITE_ONLY_IF_EXISTS) == SERVICE_NO_ERROR);

			REQUIRE(   CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea2", p_tx_rea->p_block, WRITE_ONLY_IF_EXISTS)
					== SERVICE_ERROR_WRITE_FORBIDDEN);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil_t", p_tx_fil->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);

			THEN("We get expected structure") {
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop_t") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_str));
				CHN.destroy_transaction(p_txn);

				CHN.file_lev = 0;
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str_t") == SERVICE_ERROR_BASE_FORBIDDEN);
				CHN.file_lev = 3;
				REQUIRE(CHN.get(p_txn, (pChar) "//files//tmp/jzz_ftest/fff/str_t") == SERVICE_ERROR_WRONG_BASE);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_chr));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_int));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/rea_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_rea));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/tim_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_tim));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/fil_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_fil));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_pop));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_str));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_chr));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_int));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/rea") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_rea));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/tim") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_tim));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/fil") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_fil));
				CHN.destroy_transaction(p_txn);
			}

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_NO_ERROR);
			CHN.destroy_transaction(p_txn);

			CHN.file_lev = 2;
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 3;
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.remove((pChar) "//files//tmp/jzz_ftest/fff/fil") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/fil") == SERVICE_NO_ERROR);

			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
		}

		WHEN("We check all the non applicable") {
			StaticBlockHeader hea;
			Locator loc;

			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int", p_tx_int->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.locate(loc, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop", (pChar) "value") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_NO_ERROR);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.locate(loc, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int", p_tx_fil->p_block) == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
		}

		WHEN("We test copy") {
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/ggg") == SERVICE_NO_ERROR);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop",   p_tx_pop->p_block, WRITE_EVERYTHING)  == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/str",   p_tx_str->p_block, WRITE_EVERYTHING)  == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int_t", p_tx_int->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/tim_t", p_tx_tim->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);

			THEN("We get expected structure") {
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_pop));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_str));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_int));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/tim_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_tim));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/pop") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				CHN.file_lev = 2;
				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
				REQUIRE(   CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//file//tmp/jzz_ftest/fff/pop")
						== SERVICE_ERROR_BASE_FORBIDDEN);

				CHN.file_lev = 3;
				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);

				REQUIRE(   CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//files//tmp/jzz_ftest/fff/pop")
						== SERVICE_ERROR_WRONG_BASE);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/pop") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_pop));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/str") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/str", (pChar) "//file//tmp/jzz_ftest/fff/str") == SERVICE_NO_ERROR);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/str") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_str));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/int") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/int", (pChar) "//file//tmp/jzz_ftest/fff/int_t") == SERVICE_NO_ERROR);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/int") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_int));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/tim") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/tim", (pChar) "//file//tmp/jzz_ftest/fff/tim_t") == SERVICE_NO_ERROR);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/tim") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_tim));
				CHN.destroy_transaction(p_txn);
			}
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
		}

		WHEN("We test translate") {
			REQUIRE(CHN.translate((pTuple) p_tx_pop->p_block, (pChar) "//file/anything") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//file/anything") == SERVICE_ERROR_WRONG_BASE);
		}

		CHN.destroy_transaction(p_tx_pop);
		CHN.destroy_transaction(p_tx_str);
		CHN.destroy_transaction(p_tx_chr);
		CHN.destroy_transaction(p_tx_int);
		CHN.destroy_transaction(p_tx_rea);
		CHN.destroy_transaction(p_tx_tim);
		CHN.destroy_transaction(p_tx_fil);
		CHN.destroy_transaction(p_tx_xlt);
	}

	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	  != nullptr);
	REQUIRE(CHN.zmq_requester != nullptr);

	REQUIRE(CHN.shut_down() == SERVICE_NO_ERROR);

	REQUIRE(CHN.alloc_bytes == 0);
	REQUIRE(CHN.p_buffer == nullptr);
	REQUIRE(CHN.p_free	 == nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.curl_ok == 0);
	REQUIRE(CHN.zmq_ok	== 0);

	REQUIRE(CHN.zmq_context	  == nullptr);
	REQUIRE(CHN.zmq_requester == nullptr);
}


SCENARIO("Testing http end-to-end") {

//TODO: Write tests for this!

	GIVEN("Something") {
		WHEN("someone looks at it") {
			THEN("it breaks") {
				REQUIRE(2 > 1);
			}
		}
	}
}


SCENARIO("Testing tcp end-to-end") {

//TODO: Write tests for this!

	GIVEN("Something") {
		WHEN("someone looks at it") {
			THEN("it breaks") {
				REQUIRE(2 > 1);
			}
		}
	}
}

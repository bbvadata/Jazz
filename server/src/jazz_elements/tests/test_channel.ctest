/* Jazz (c) 2018-2021 kaalam.ai (The Authors of Jazz), using (under the same license):

	1. Biomodelling - The AATBlockQueue class (c) Jacques Basaldúa, 2009-2012 licensed
	  exclusively for the use in the Jazz server software.

	  Copyright 2009-2012 Jacques Basaldúa

	2. BBVA - Jazz: A lightweight analytical web server for data-driven applications.

      Copyright 2016-2017 Banco Bilbao Vizcaya Argentaria, S.A.

      This product includes software developed at

      BBVA (https://www.bbva.com/)

	3. LMDB, Copyright 2011-2017 Howard Chu, Symas Corp. All rights reserved.

	  Licensed under http://www.OpenLDAP.org/license.html


	  Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	  http://www.apache.org/licenses/LICENSE-2.0

	  Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/


using namespace jazz_elements;


// Utils
// -----

bool compare_to_tensor(pTransaction &p_txn, pTransaction &p_txo) {
	REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);

	REQUIRE((p_txo->p_block->cell_type & 0xff) <= 8);

	REQUIRE(p_txn->p_block->size == p_txo->p_block->size*(p_txo->p_block->cell_type & 0xff));

	for (int i = 0; i < p_txn->p_block->size; i++)
		if (p_txn->p_block->tensor.cell_byte[i] != p_txo->p_block->tensor.cell_byte[i])
			return false;

	return true;
}

bool compare_to_block(pTransaction &p_txn, pTransaction &p_txo) {
	REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);

	REQUIRE(p_txn->p_block->size == p_txo->p_block->total_bytes);

	uint8_t *p_bl = (uint8_t *) p_txo->p_block;

	for (int i = 0; i < p_txn->p_block->size; i++)
		if (p_txn->p_block->tensor.cell_byte[i] != p_bl[i])
			return false;

	return true;
}

// Tests
// -----

SCENARIO("Basics tests") {

	REQUIRE(sizeof(Socket) == 128);

	REQUIRE(TenBitsAtAddress("0-mq") == BASE_0_MQ_10BIT);
	REQUIRE(TenBitsAtAddress("bash") == BASE_BASH_10BIT);
	REQUIRE(TenBitsAtAddress("file") == BASE_FILE_10BIT);
	REQUIRE(TenBitsAtAddress("http") == BASE_HTTP_10BIT);

	char buffer[16] = "abcdefghij12345";
	REQUIRE(strnlen(buffer, 16) == 15);

	buffer[15] = '6';
	REQUIRE(strnlen(buffer, 16) == 16);

	buffer[1] = 0;
	REQUIRE(strnlen(buffer, 16) == 1);

	buffer[0] = 0;
	REQUIRE(strnlen(buffer, 16) == 0);
}


SCENARIO("Testing bash end-to-end") {

	REQUIRE(CHN.start() == SERVICE_NO_ERROR);

	REQUIRE(CHN.max_transactions > 0);
	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.warn_alloc_bytes > 0);
	REQUIRE(CHN.fail_alloc_bytes > 0);
	REQUIRE(CHN.alloc_warning_issued == false);
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN.p_free	 == CHN.p_buffer);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next == &pStoredTransaction(CHN.p_buffer)[1]);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next->p_next == &pStoredTransaction(CHN.p_buffer)[2]);
	REQUIRE(	pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 2].p_next
			== &pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1]);
	REQUIRE(pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1].p_next == nullptr);
	REQUIRE(CHN._lock_ == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	!= nullptr);

	GIVEN("We have some blocks") {
		pTransaction p_tx_int, p_tx_inp, p_tx_res, p_tx_xlt;

		char input[] = {"for line in {0..4}; do\n"
						"  case $line in\n"
						"    0)\n"
						"      printf \"There was an Old Man in a boat, \\n\"\n"
						"	  ;;\n"
						"    1)\n"
						"      printf \"Who said: \\\"I'm afloat! I'm afloat!\\\" \\n\"\n"
						"	  ;;\n"
						"    2)\n"
						"      printf \"When they said: \\\"No, you ain't!\\\" \\n\"\n"
						"	  ;;\n"
						"    3)\n"
						"      printf \"He was ready to faint, \\n\"\n"
						"	  ;;\n"
						"    *)\n"
						"      printf \"That unhappy Old Man in a boat. \\n\"\n"
						"      ;;\n"
						"  esac\n"
						"done\n"};

		char result[] = {"There was an Old Man in a boat, \n"
						 "Who said: \"I'm afloat! I'm afloat!\" \n"
						 "When they said: \"No, you ain't!\" \n"
						 "He was ready to faint, \n"
						 "That unhappy Old Man in a boat. \n"};

		int dim[MAX_TENSOR_RANK] = {160, 0};

		REQUIRE(CHN.new_block(p_tx_int, CELL_TYPE_INTEGER, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);
		p_tx_int->p_block->tensor.cell_int[0]	= 1;
		p_tx_int->p_block->tensor.cell_int[159] = 159;

		dim[0] = strlen(input) + 1;

		REQUIRE(CHN.new_block(p_tx_inp, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);

		memcpy(&p_tx_inp->p_block->tensor.cell_byte[0], input, dim[0]);

		REQUIRE(p_tx_inp->p_block->tensor.cell_byte[0] == 'f');
		REQUIRE(input[0] == 'f');

		dim[0] = strlen(result) + 100;

		REQUIRE(CHN.new_block(p_tx_res, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);

		StaticBlockHeader hea[2]	 = {0, 0};
		Name			  names[2]	 = {"input", "result"};
		pBlock			  p_block[2] = {p_tx_inp->p_block, p_tx_res->p_block};

		memcpy(&hea[0], p_block[0], sizeof(StaticBlockHeader));
		memcpy(&hea[1], p_block[1], sizeof(StaticBlockHeader));

		p_block[0]->get_dimensions(hea[0].range.dim);
		p_block[1]->get_dimensions(hea[1].range.dim);

		REQUIRE(CHN.new_block(p_tx_xlt, 2, hea, names, p_block) == SERVICE_NO_ERROR);

		pTransaction p_txn;

		WHEN("We test new_entity()/put()/get()/remove()") {
			REQUIRE(CHN.new_entity((pChar) "//bash//anything") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.new_entity((pChar) "/bash//anything") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.remove((pChar) "//bash//anything") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.remove((pChar) "/bash//anything") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.get(p_txn, (pChar) "//bash//this/that") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.get(p_txn, (pChar) "/bash//this/that") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.put((pChar) "//bash//this/that", p_tx_int->p_block) == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.put((pChar) "/bash//this/that", p_tx_int->p_block) == SERVICE_ERROR_WRONG_ARGUMENTS);
		}
		WHEN("We check all the non applicable") {
			StaticBlockHeader hea;
			Locator loc;

			REQUIRE(CHN.locate(loc, (pChar) "//bash//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/pop", (pChar) "value") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//bash//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.locate(loc, (pChar) "//bash//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/int", p_tx_int->p_block) == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//bash//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//bash//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);
		}

		WHEN("We test copy") {
			REQUIRE(CHN.copy((pChar) "//bash/where", (pChar) "//bash/what") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.copy((pChar) "//bash/where", (pChar) "/bash/what") == SERVICE_ERROR_WRONG_ARGUMENTS);
		}

		WHEN("We test translate") {
			REQUIRE(CHN.translate((pTuple) p_tx_int->p_block, (pChar) "//bash/exec") == SERVICE_ERROR_WRONG_ARGUMENTS);

			CHN.can_bash = 0;
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//bash/exec") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.can_bash = 1;
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//bash/exec") == SERVICE_NO_ERROR);

			REQUIRE(p_tx_xlt->p_block->cell_type == CELL_TYPE_TUPLE_ITEM);
			REQUIRE(p_tx_xlt->p_block->size == 2);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "input") == 0);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "result") == 1);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(0)->cell_type == CELL_TYPE_BYTE);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(1)->cell_type == CELL_TYPE_BYTE);

			pChar p_res = (pChar) &pTuple(p_tx_xlt->p_block)->get_block(1)->tensor.cell_byte[0];

			REQUIRE(strcmp(p_res, result) == 0);
		}

		CHN.destroy_transaction(p_tx_int);
		CHN.destroy_transaction(p_tx_inp);
		CHN.destroy_transaction(p_tx_res);
		CHN.destroy_transaction(p_tx_xlt);
	}

	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context != nullptr);

	REQUIRE(CHN.shut_down() == SERVICE_NO_ERROR);

	REQUIRE(CHN.alloc_bytes == 0);
	REQUIRE(CHN.p_buffer == nullptr);
	REQUIRE(CHN.p_free	 == nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.curl_ok == 0);
	REQUIRE(CHN.zmq_ok	== 0);

	REQUIRE(CHN.zmq_context == nullptr);
}


SCENARIO("Testing file end-to-end") {

	REQUIRE(CHN.start() == SERVICE_NO_ERROR);

	REQUIRE(CHN.max_transactions > 0);
	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.warn_alloc_bytes > 0);
	REQUIRE(CHN.fail_alloc_bytes > 0);
	REQUIRE(CHN.alloc_warning_issued == false);
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN.p_free	 == CHN.p_buffer);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next == &pStoredTransaction(CHN.p_buffer)[1]);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next->p_next == &pStoredTransaction(CHN.p_buffer)[2]);
	REQUIRE(	pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 2].p_next
			== &pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1]);
	REQUIRE(pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1].p_next == nullptr);
	REQUIRE(CHN._lock_ == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	!= nullptr);

	GIVEN("We have some blocks and indices") {
		Index txt;

		txt["one__"] = "Abc ..";
		txt["two__"] = "[[1,2,3],%20[1,2,3]]";
		txt["three"] = "";
		txt["_four"] = "A multiline string\nis okay\n";
		txt["fi_ve"] = "UTF8 ¡what!\n\nLöwe\n";

		pTransaction p_tx_pop, p_tx_str, p_tx_chr, p_tx_int, p_tx_rea, p_tx_tim, p_tx_fil, p_tx_xlt;

		int dim[MAX_TENSOR_RANK] = {20, 5, 0};

		REQUIRE(CHN.new_block(p_tx_pop, txt) == SERVICE_NO_ERROR);
		REQUIRE(CHN.new_block(p_tx_str, CELL_TYPE_STRING, nullptr, FILL_WITH_TEXTFILE, nullptr, 0, (pChar) "Line\ntwo\nthree") == 0);
		REQUIRE(CHN.new_block(p_tx_chr, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);
		p_tx_chr->p_block->tensor.cell_byte[0]  = 1;
		p_tx_chr->p_block->tensor.cell_byte[99] = 99;

		dim[1] = 8;
		REQUIRE(CHN.new_block(p_tx_int, CELL_TYPE_INTEGER, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);
		p_tx_int->p_block->tensor.cell_int[0]	= 1;
		p_tx_int->p_block->tensor.cell_int[159] = 159;

		dim[1] = 4;
		REQUIRE(CHN.new_block(p_tx_rea, CELL_TYPE_DOUBLE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);
		p_tx_rea->p_block->tensor.cell_double[0]  = 1.23;
		p_tx_rea->p_block->tensor.cell_double[79] = 21.345;

		dim[1] = 1;
		REQUIRE(CHN.new_block(p_tx_tim, CELL_TYPE_TIME, dim, FILL_NEW_DONT_FILL) == SERVICE_NO_ERROR);

		struct tm junk		= {0};
		struct tm *timeinfo = &junk;

		char buffer[20] = {"2021-08-01 12:13:14"};
		char fmt[20]	= {"%Y-%m-%d %H:%M:%S"};

		REQUIRE(strptime(buffer, fmt, timeinfo) != nullptr);

		REQUIRE(timeinfo->tm_mday == 1);

		for (int i = 0; i < 20; i++) {
			timeinfo->tm_mday =  1 + (3*i % 29);
			timeinfo->tm_hour =  7 + (5*i % 7);
			timeinfo->tm_min  = 13 + (7*i % 31);
			p_tx_tim->p_block->tensor.cell_time[i] = timegm(timeinfo);
		}

		dim[1] = 0;
		REQUIRE(CHN.new_block(p_tx_fil, CELL_TYPE_INTEGER, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);
		p_tx_fil->p_block->range.filter.length = 2;
		p_tx_fil->p_block->tensor.cell_int[0]  = 0;
		p_tx_fil->p_block->tensor.cell_int[1]  = 2;

		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_tim->p_block));
		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_rea->p_block));
		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_int->p_block));
		REQUIRE(p_tx_fil->p_block->can_filter(p_tx_chr->p_block));

		StaticBlockHeader hea[2]	 = {0, 0};
		Name			  names[2]	 = {"input", "result"};
		pBlock			  p_block[2] = {p_tx_rea->p_block, p_tx_int->p_block};

		memcpy(&hea[0], p_block[0], sizeof(StaticBlockHeader));
		memcpy(&hea[1], p_block[1], sizeof(StaticBlockHeader));

		p_block[0]->get_dimensions(hea[0].range.dim);
		p_block[1]->get_dimensions(hea[1].range.dim);

		REQUIRE(CHN.new_block(p_tx_xlt, 2, hea, names, p_block) == SERVICE_NO_ERROR);

		pTransaction p_txn;
		pBlock p_blk;

		CHN.remove((pChar) "//file//tmp/jzz_ftest");
		CHN.new_entity((pChar) "//file//tmp/jzz_ftest");

		WHEN("We test new_entity()/remove()") {
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_NO_ERROR);

			CHN.file_lev = 1;
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 2;
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_NO_ERROR);
			CHN.file_lev = 3;
			REQUIRE(CHN.new_entity((pChar) "//files//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_IO_ERROR);
			CHN.file_lev = 2;
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/ff") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 3;

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/folder/blk", p_tx_int->p_block) == SERVICE_NO_ERROR);

			THEN("We get expected structure") {
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder/blk") == SERVICE_NO_ERROR);
				REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder/blk4") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_NO_ERROR);
				REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_INDEX);
				REQUIRE(p_txn->p_hea->index["blk"] == "file");
				REQUIRE(p_txn->p_hea->index["ff"] == "folder");
				REQUIRE(p_txn->p_hea->index.size() == 2);
				CHN.destroy_transaction(p_txn);
			}

			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/folder/blk/aaa") == SERVICE_ERROR_IO_ERROR);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/folder/blk") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/folder") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_INDEX);
			CHN.destroy_transaction(p_txn);
		}
		WHEN("We test put()/get()/remove() of keys") {
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);

			REQUIRE(   CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop_t", p_tx_pop->p_block, WRITE_TENSOR_DATA)
					== SERVICE_ERROR_WRITE_FORBIDDEN);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/str_t", p_tx_str->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/chr_t", p_tx_chr->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int_t", p_tx_int->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea_t", p_tx_rea->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/tim_t", p_tx_tim->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil_t", p_tx_fil->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);

			CHN.file_lev = 1;
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 2;
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 3;
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//files//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_ERROR_WRONG_BASE);

			p_tx_pop->p_block->close_block();
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			p_tx_str->p_block->close_block();
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/str", p_tx_str->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			p_tx_chr->p_block->close_block();
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/chr", p_tx_chr->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			p_tx_int->p_block->close_block();
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int", p_tx_int->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			p_tx_rea->p_block->close_block();
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea", p_tx_rea->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			p_tx_tim->p_block->close_block();
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/tim", p_tx_tim->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			p_tx_fil->p_block->close_block();
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil", p_tx_fil->p_block, WRITE_ONLY_IF_NOT_EXISTS) == SERVICE_NO_ERROR);

			REQUIRE(   CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil", p_tx_fil->p_block, WRITE_ONLY_IF_NOT_EXISTS)
					== SERVICE_ERROR_WRITE_FORBIDDEN);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea", p_tx_rea->p_block, WRITE_ONLY_IF_EXISTS) == SERVICE_NO_ERROR);

			REQUIRE(   CHN.put((pChar) "//file//tmp/jzz_ftest/fff/rea2", p_tx_rea->p_block, WRITE_ONLY_IF_EXISTS)
					== SERVICE_ERROR_WRITE_FORBIDDEN);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/fil_t", p_tx_fil->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);

			THEN("We get expected structure") {
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop_t") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_str));
				CHN.destroy_transaction(p_txn);

				CHN.file_lev = 0;
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str_t") == SERVICE_ERROR_BASE_FORBIDDEN);
				CHN.file_lev = 3;
				REQUIRE(CHN.get(p_txn, (pChar) "//files//tmp/jzz_ftest/fff/str_t") == SERVICE_ERROR_WRONG_BASE);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_chr));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_int));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/rea_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_rea));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/tim_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_tim));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/fil_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_fil));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_pop));
				p_blk = (pBlock) &p_txn->p_block->tensor;
				REQUIRE(p_blk->check_hash());
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_str));
				p_blk = (pBlock) &p_txn->p_block->tensor;
				REQUIRE(p_blk->check_hash());
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_chr));
				p_blk = (pBlock) &p_txn->p_block->tensor;
				REQUIRE(p_blk->check_hash());
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_int));
				p_blk = (pBlock) &p_txn->p_block->tensor;
				REQUIRE(p_blk->check_hash());
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/rea") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_rea));
				p_blk = (pBlock) &p_txn->p_block->tensor;
				REQUIRE(p_blk->check_hash());
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/tim") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_tim));
				p_blk = (pBlock) &p_txn->p_block->tensor;
				REQUIRE(p_blk->check_hash());
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/fil") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_fil));
				p_blk = (pBlock) &p_txn->p_block->tensor;
				REQUIRE(p_blk->check_hash());
				CHN.destroy_transaction(p_txn);
			}

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_NO_ERROR);
			CHN.destroy_transaction(p_txn);

			CHN.file_lev = 2;
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.file_lev = 3;
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/chr") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.remove((pChar) "//files//tmp/jzz_ftest/fff/fil") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff/fil") == SERVICE_NO_ERROR);

			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
		}

		WHEN("We check all the non applicable") {
			StaticBlockHeader hea;
			Locator loc;

			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop", p_tx_pop->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int", p_tx_int->p_block, WRITE_EVERYTHING) == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.locate(loc, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop", (pChar) "value") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_NO_ERROR);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.locate(loc, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int", p_tx_fil->p_block) == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//file//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
		}

		WHEN("We test copy") {
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
			REQUIRE(CHN.new_entity((pChar) "//file//tmp/jzz_ftest/ggg") == SERVICE_NO_ERROR);

			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/pop",   p_tx_pop->p_block, WRITE_EVERYTHING)  == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/str",   p_tx_str->p_block, WRITE_EVERYTHING)  == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/int_t", p_tx_int->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//file//tmp/jzz_ftest/fff/tim_t", p_tx_tim->p_block, WRITE_TENSOR_DATA) == SERVICE_NO_ERROR);

			THEN("We get expected structure") {
				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_pop));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/str") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_str));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/int_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_int));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/fff/tim_t") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_tim));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/pop") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				CHN.file_lev = 2;
				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);
				REQUIRE(   CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//file//tmp/jzz_ftest/fff/pop")
						== SERVICE_ERROR_BASE_FORBIDDEN);

				CHN.file_lev = 3;
				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//file//tmp/jzz_ftest/fff/pop") == SERVICE_NO_ERROR);

				REQUIRE(   CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/pop", (pChar) "//files//tmp/jzz_ftest/fff/pop")
						== SERVICE_ERROR_WRONG_BASE);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/pop") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_pop));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/str") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/str", (pChar) "//file//tmp/jzz_ftest/fff/str") == SERVICE_NO_ERROR);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/str") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_block(p_txn, p_tx_str));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/int") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/int", (pChar) "//file//tmp/jzz_ftest/fff/int_t") == SERVICE_NO_ERROR);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/int") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_int));
				CHN.destroy_transaction(p_txn);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/tim") == SERVICE_ERROR_BLOCK_NOT_FOUND);

				REQUIRE(CHN.copy((pChar) "//file//tmp/jzz_ftest/ggg/tim", (pChar) "//file//tmp/jzz_ftest/fff/tim_t") == SERVICE_NO_ERROR);

				REQUIRE(CHN.get(p_txn, (pChar) "//file//tmp/jzz_ftest/ggg/tim") == SERVICE_NO_ERROR);
				REQUIRE(compare_to_tensor(p_txn, p_tx_tim));
				CHN.destroy_transaction(p_txn);
			}
			REQUIRE(CHN.remove((pChar) "//file//tmp/jzz_ftest/fff") == SERVICE_NO_ERROR);
		}

		WHEN("We test translate") {
			REQUIRE(CHN.translate((pTuple) p_tx_pop->p_block, (pChar) "//file/anything") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//file/anything") == SERVICE_ERROR_WRONG_BASE);
		}

		CHN.destroy_transaction(p_tx_pop);
		CHN.destroy_transaction(p_tx_str);
		CHN.destroy_transaction(p_tx_chr);
		CHN.destroy_transaction(p_tx_int);
		CHN.destroy_transaction(p_tx_rea);
		CHN.destroy_transaction(p_tx_tim);
		CHN.destroy_transaction(p_tx_fil);
		CHN.destroy_transaction(p_tx_xlt);
	}

	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context != nullptr);

	REQUIRE(CHN.shut_down() == SERVICE_NO_ERROR);

	REQUIRE(CHN.alloc_bytes == 0);
	REQUIRE(CHN.p_buffer == nullptr);
	REQUIRE(CHN.p_free	 == nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.curl_ok == 0);
	REQUIRE(CHN.zmq_ok	== 0);

	REQUIRE(CHN.zmq_context == nullptr);
}


SCENARIO("Testing 0-mq end-to-end") {

	REQUIRE(CHN.start() == SERVICE_NO_ERROR);

	REQUIRE(CHN.max_transactions > 0);
	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.warn_alloc_bytes > 0);
	REQUIRE(CHN.fail_alloc_bytes > 0);
	REQUIRE(CHN.alloc_warning_issued == false);
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN.p_free	 == CHN.p_buffer);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next == &pStoredTransaction(CHN.p_buffer)[1]);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next->p_next == &pStoredTransaction(CHN.p_buffer)[2]);
	REQUIRE(	pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 2].p_next
			== &pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1]);
	REQUIRE(pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1].p_next == nullptr);
	REQUIRE(CHN._lock_ == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	!= nullptr);

	GIVEN("We have some blocks") {
		pTransaction p_tx_int, p_tx_inp, p_tx_res, p_tx_xlt, p_tx_pi1, p_tx_pi2;

		char input[] = {"for line in {0..4}; do\n"
						"  case $line in\n"
						"    0)\n"
						"      printf \"There was an Old Man in a boat, \\n\"\n"
						"	  ;;\n"
						"    1)\n"
						"      printf \"Who said: \\\"I'm afloat! I'm afloat!\\\" \\n\"\n"
						"	  ;;\n"
						"    2)\n"
						"      printf \"When they said: \\\"No, you ain't!\\\" \\n\"\n"
						"	  ;;\n"
						"    3)\n"
						"      printf \"He was ready to faint, \\n\"\n"
						"	  ;;\n"
						"    *)\n"
						"      printf \"That unhappy Old Man in a boat. \\n\"\n"
						"      ;;\n"
						"  esac\n"
						"done\n"};

		char res_alpha[] = {"forlinein04do\n"
							"caselinein\n"
							"0\n"
							"printfTherewasanOldManinaboatn\n"
							"\n"
							"1\n"
							"printfWhosaidImafloatImafloatn\n"
							"\n"
							"2\n"
							"printfWhentheysaidNoyouaintn\n"
							"\n"
							"3\n"
							"printfHewasreadytofaintn\n"
							"\n"
							"\n"
							"printfThatunhappyOldManinaboatn\n"
							"\n"
							"esac\n"
							"done\n"};

		char res_a2m[] = {"flieidcaelieiifheeaaldaiabaifhaidmaflamaflaifheheaidaiifeaeadfaiifhahaldaiabaeacde"};

		int dim[MAX_TENSOR_RANK] = {160, 0};

		REQUIRE(CHN.new_block(p_tx_int, CELL_TYPE_INTEGER, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);
		p_tx_int->p_block->tensor.cell_int[0]	= 1;
		p_tx_int->p_block->tensor.cell_int[159] = 159;

		dim[0] = strlen(input) + 1;

		REQUIRE(CHN.new_block(p_tx_inp, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);

		memcpy(&p_tx_inp->p_block->tensor.cell_byte[0], input, dim[0]);

		REQUIRE(p_tx_inp->p_block->tensor.cell_byte[0] == 'f');
		REQUIRE(input[0] == 'f');

		dim[0] = strlen(res_alpha) + 100;

		REQUIRE(CHN.new_block(p_tx_res, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);

		StaticBlockHeader hea[2]	 = {0, 0};
		Name			  names[2]	 = {"input", "result"};
		pBlock			  p_block[2] = {p_tx_inp->p_block, p_tx_res->p_block};

		memcpy(&hea[0], p_block[0], sizeof(StaticBlockHeader));
		memcpy(&hea[1], p_block[1], sizeof(StaticBlockHeader));

		p_block[0]->get_dimensions(hea[0].range.dim);
		p_block[1]->get_dimensions(hea[1].range.dim);

		REQUIRE(CHN.new_block(p_tx_xlt, 2, hea, names, p_block) == SERVICE_NO_ERROR);

		REQUIRE(   CHN.new_block(p_tx_pi1, CELL_TYPE_STRING, nullptr, FILL_WITH_TEXTFILE, nullptr, 0, (pChar) "tcp://localhost:5555")
				== SERVICE_NO_ERROR);

		REQUIRE(p_tx_pi1->p_block->size == 1);

		REQUIRE(   CHN.new_block(p_tx_pi2, CELL_TYPE_STRING, nullptr, FILL_WITH_TEXTFILE, nullptr, 0, (pChar) "tcp://localhost:5566")
				== SERVICE_NO_ERROR);

		REQUIRE(p_tx_pi2->p_block->size == 1);

		pTransaction p_txn;

		WHEN("We test new_entity()/put()/get()/remove()") {
			REQUIRE(CHN.pipes.size() == 0);

			REQUIRE(CHN.new_entity((pChar) "//0-mq//anything") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.new_entity((pChar) "/0-mq//anything") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.remove((pChar) "//0-mq//anything") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.remove((pChar) "/0-mq//anything") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.remove((pChar) "//0-mq/pipeline/aaa") == SERVICE_ERROR_ENTITY_NOT_FOUND);
			REQUIRE(CHN.remove((pChar) "//0-mqq//anything") == SERVICE_ERROR_WRONG_BASE);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq//this/that") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.get(p_txn, (pChar) "/0-mq//this/that") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq/pipeline/aaa") == SERVICE_ERROR_ENTITY_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//0-mqq//this/that") == SERVICE_ERROR_WRONG_BASE);

			REQUIRE(CHN.put((pChar) "//0-mq//this/that", p_tx_int->p_block) == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.put((pChar) "/0-mq//this/that", p_tx_int->p_block) == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.put((pChar) "//0-mq/pipeline/aaa", p_tx_int->p_block) == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.put((pChar) "//0-mqq//this/that", p_tx_int->p_block) == SERVICE_ERROR_WRONG_BASE);

			CHN.zmq_ok = 0;
			REQUIRE(CHN.remove((pChar) "//0-mq/pipeline/aaa") == SERVICE_ERROR_BASE_FORBIDDEN);
			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq/pipeline/aaa") == SERVICE_ERROR_BASE_FORBIDDEN);
			REQUIRE(CHN.put((pChar) "//0-mq/pipeline/aaa", p_tx_int->p_block) == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.zmq_ok = 1;
		}
		WHEN("We check all the non applicable") {
			StaticBlockHeader hea;
			Locator loc;

			REQUIRE(CHN.locate(loc, (pChar) "//0-mq//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq//tmp/jzz_ftest/fff/pop", (pChar) "value") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//0-mq//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//0-mq//tmp/jzz_ftest/fff/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.locate(loc, (pChar) "//0-mq//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq//tmp/jzz_ftest/fff/int", p_tx_int->p_block) == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//0-mq//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(hea, (pChar) "//0-mq//tmp/jzz_ftest/fff/int") == SERVICE_ERROR_NOT_APPLICABLE);
		}

		WHEN("We test copy") {
			REQUIRE(CHN.pipes.size() == 0);

			REQUIRE(CHN.copy((pChar) "//0-mq/where", (pChar) "//0-mq/what") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.copy((pChar) "//0-mq/where", (pChar) "//0-mq/pipeline/aaa") == SERVICE_ERROR_ENTITY_NOT_FOUND);

			REQUIRE(CHN.put((pChar) "//0-mq/pipeline/aaa", p_tx_pi1->p_block) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//0-mq/pipeline/aaa", p_tx_pi1->p_block) == SERVICE_ERROR_WRITE_FORBIDDEN);

			REQUIRE(CHN.pipes.size() == 1);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq/pipeline/aaa") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_STRING);
			REQUIRE(p_txn->p_block->size == 1);
			REQUIRE(strcmp(p_txn->p_block->get_string(0), "tcp://localhost:5555") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq/pipeline/bbb") == SERVICE_ERROR_ENTITY_NOT_FOUND);

			REQUIRE(CHN.copy((pChar) "//0-mq/pipeline/bbb", (pChar) "//0-mq/pipeline/aaa") == SERVICE_NO_ERROR);

			REQUIRE(CHN.pipes.size() == 2);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq/pipeline/bbb") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_STRING);
			REQUIRE(p_txn->p_block->size == 1);
			REQUIRE(strcmp(p_txn->p_block->get_string(0), "tcp://localhost:5555") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.remove((pChar) "//0-mq/pipeline/bbb") == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq/pipeline/bbb") == SERVICE_ERROR_ENTITY_NOT_FOUND);
			REQUIRE(CHN.pipes.size() == 1);

			REQUIRE(CHN.remove((pChar) "//0-mq/pipeline/aaa") == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//0-mq/pipeline/aaa") == SERVICE_ERROR_ENTITY_NOT_FOUND);
			REQUIRE(CHN.pipes.size() == 0);

			REQUIRE(CHN.remove((pChar) "//0-mq/pipeline/aaa") == SERVICE_ERROR_ENTITY_NOT_FOUND);
		}

		WHEN("We test translate") {
			REQUIRE(CHN.pipes.size() == 0);

			REQUIRE(CHN.translate((pTuple) p_tx_int->p_block, (pChar) "//0-mq/exec") == SERVICE_ERROR_WRONG_ARGUMENTS);

			CHN.zmq_ok = 0;
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//0-mq/exec") == SERVICE_ERROR_BASE_FORBIDDEN);
			CHN.zmq_ok = 1;

			REQUIRE(CHN.put((pChar) "//0-mq/pipeline/alpha", p_tx_pi1->p_block) == SERVICE_NO_ERROR);
			REQUIRE(CHN.put((pChar) "//0-mq/pipeline/a2m", p_tx_pi2->p_block) == SERVICE_NO_ERROR);

			REQUIRE(CHN.pipes.size() == 2);

			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//0-mq/alpha") == SERVICE_NO_ERROR);

			REQUIRE(p_tx_xlt->p_block->cell_type == CELL_TYPE_TUPLE_ITEM);
			REQUIRE(p_tx_xlt->p_block->size == 2);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "input") == 0);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "result") == 1);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(0)->cell_type == CELL_TYPE_BYTE);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(1)->cell_type == CELL_TYPE_BYTE);

			pChar p_res = (pChar) &pTuple(p_tx_xlt->p_block)->get_block(1)->tensor.cell_byte[0];

			REQUIRE(strcmp(p_res, res_alpha) == 0);

			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//0-mq/a2m") == SERVICE_NO_ERROR);

			REQUIRE(p_tx_xlt->p_block->cell_type == CELL_TYPE_TUPLE_ITEM);
			REQUIRE(p_tx_xlt->p_block->size == 2);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "input") == 0);
			REQUIRE(pTuple(p_tx_xlt->p_block)->index((pChar) "result") == 1);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(0)->cell_type == CELL_TYPE_BYTE);
			REQUIRE(pTuple(p_tx_xlt->p_block)->get_block(1)->cell_type == CELL_TYPE_BYTE);

			p_res = (pChar) &pTuple(p_tx_xlt->p_block)->get_block(1)->tensor.cell_byte[0];

			REQUIRE(strcmp(p_res, res_a2m) == 0);

			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//0-mqq/exec") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//0-mq/what") == SERVICE_ERROR_ENTITY_NOT_FOUND);

			REQUIRE(CHN.remove((pChar) "//0-mq/pipeline/alpha") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//0-mq/pipeline/a2m") == SERVICE_NO_ERROR);

			REQUIRE(CHN.pipes.size() == 0);
		}

		CHN.destroy_transaction(p_tx_int);
		CHN.destroy_transaction(p_tx_inp);
		CHN.destroy_transaction(p_tx_res);
		CHN.destroy_transaction(p_tx_xlt);
		CHN.destroy_transaction(p_tx_pi1);
		CHN.destroy_transaction(p_tx_pi2);
	}

	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context != nullptr);

	REQUIRE(CHN.shut_down() == SERVICE_NO_ERROR);

	REQUIRE(CHN.alloc_bytes == 0);
	REQUIRE(CHN.p_buffer == nullptr);
	REQUIRE(CHN.p_free	 == nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.curl_ok == 0);
	REQUIRE(CHN.zmq_ok	== 0);

	REQUIRE(CHN.zmq_context == nullptr);
}


SCENARIO("Testing http end-to-end") {

	REQUIRE(CHN.start() == SERVICE_NO_ERROR);

	REQUIRE(CHN.max_transactions > 0);
	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.warn_alloc_bytes > 0);
	REQUIRE(CHN.fail_alloc_bytes > 0);
	REQUIRE(CHN.alloc_warning_issued == false);
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN.p_free	 == CHN.p_buffer);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next == &pStoredTransaction(CHN.p_buffer)[1]);
	REQUIRE(pStoredTransaction(CHN.p_free)->p_next->p_next == &pStoredTransaction(CHN.p_buffer)[2]);
	REQUIRE(	pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 2].p_next
			== &pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1]);
	REQUIRE(pStoredTransaction(CHN.p_buffer)[CHN.max_transactions - 1].p_next == nullptr);
	REQUIRE(CHN._lock_ == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context	!= nullptr);

	GIVEN("We have some blocks and indices") {
		pTransaction p_tx_idx, p_tx_str, p_tx_rea, p_tx_tim, p_tx_xlt, p_tx_buf;

		REQUIRE(CHN.new_block(p_tx_str, CELL_TYPE_STRING, nullptr, FILL_WITH_TEXTFILE, nullptr, 0, (pChar) "Line\ntwo\nthree") == 0);

		int dim[MAX_TENSOR_RANK] = {20, 5, 0};

		REQUIRE(CHN.new_block(p_tx_rea, CELL_TYPE_DOUBLE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);
		p_tx_rea->p_block->tensor.cell_double[0]  = 1.23;
		p_tx_rea->p_block->tensor.cell_double[79] = 21.345;

		dim[1] = 1;
		REQUIRE(CHN.new_block(p_tx_tim, CELL_TYPE_TIME, dim, FILL_NEW_DONT_FILL) == SERVICE_NO_ERROR);

		struct tm junk		= {0};
		struct tm *timeinfo = &junk;

		char buffer[20] = {"2021-08-01 12:13:14"};
		char fmt[20]	= {"%Y-%m-%d %H:%M:%S"};

		REQUIRE(strptime(buffer, fmt, timeinfo) != nullptr);

		REQUIRE(timeinfo->tm_mday == 1);

		for (int i = 0; i < 20; i++) {
			timeinfo->tm_mday =  1 + (3*i % 29);
			timeinfo->tm_hour =  7 + (5*i % 7);
			timeinfo->tm_min  = 13 + (7*i % 31);
			p_tx_tim->p_block->tensor.cell_time[i] = timegm(timeinfo);
		}

		StaticBlockHeader hea[2]	 = {0, 0};
		Name			  names[2]	 = {"input", "result"};
		pBlock			  p_block[2] = {p_tx_rea->p_block, p_tx_tim->p_block};

		memcpy(&hea[0], p_block[0], sizeof(StaticBlockHeader));
		memcpy(&hea[1], p_block[1], sizeof(StaticBlockHeader));

		p_block[0]->get_dimensions(hea[0].range.dim);
		p_block[1]->get_dimensions(hea[1].range.dim);

		REQUIRE(CHN.new_block(p_tx_xlt, 2, hea, names, p_block) == SERVICE_NO_ERROR);

		REQUIRE(CHN.new_block(p_tx_idx, CELL_TYPE_INDEX) == SERVICE_NO_ERROR);

		p_tx_idx->p_hea->index["URL"] = "http://127.0.0.1:5000/test/capital/";

		dim[0] = 256;
		dim[1] = 0;
		REQUIRE(CHN.new_block(p_tx_buf, CELL_TYPE_BYTE, dim, FILL_NEW_WITH_ZERO) == SERVICE_NO_ERROR);

		pTransaction p_txn;
		pChar p_ret;

		WHEN("We test new_entity()/remove()") {
			REQUIRE(CHN.new_entity((pChar) "//http/anything") == SERVICE_ERROR_WRONG_BASE);
			REQUIRE(CHN.new_entity((pChar) "/http/anything") == SERVICE_ERROR_WRONG_ARGUMENTS);

			REQUIRE(CHN.connect.size() == 0);
		}
		WHEN("We test put()/get()/remove() on direct links") {
			REQUIRE(CHN.get(p_txn, (pChar) "//http/http://127.0.0.1:5000/test/capital/Germany") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//http/http://127.0.0.1:5000/test/capital/Spain") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Madrid") == 0);
			CHN.destroy_transaction(p_txn);

			strcpy((pChar) &p_tx_buf->p_block->tensor.cell_byte[0], "Berlin");

			REQUIRE(CHN.put((pChar) "//http/http://127.0.0.1:5000/test/capital/Germany", p_tx_buf->p_block) == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/http://127.0.0.1:5000/test/capital/Germany") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Berlin") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.remove((pChar) "//http/http://127.0.0.1:5000/test/capital/Germany") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//http/http://127.0.0.1:5000/test/capital/Germany") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/http://127.0.0.1:5000/test/capital/madAGASCAR") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Antananarivo") == 0);
			CHN.destroy_transaction(p_txn);

			strcpy((pChar) &p_tx_buf->p_block->tensor.cell_byte[0], "Rome");

			REQUIRE(CHN.put((pChar) "//http/http://127.0.0.1:5000/test/capital/Italy", p_tx_buf->p_block) == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/http://127.0.0.1:5000/test/capital/italy") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Rome") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.remove((pChar) "//http/http://127.0.0.1:5000/test/capital/ITALY") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//http/http://127.0.0.1:5000/test/capital/Italy") == SERVICE_ERROR_BLOCK_NOT_FOUND);
		}
		WHEN("We test put()/get()/remove() on a connection") {
			REQUIRE(CHN.connect.size() == 0);

			REQUIRE(CHN.put((pChar) "//http/connection/capitals", p_tx_idx->p_block) == SERVICE_NO_ERROR);

			REQUIRE(CHN.connect.size() == 1);

			REQUIRE(CHN.put((pChar) "//http/connection/capitals", p_tx_idx->p_block) == SERVICE_ERROR_WRITE_FORBIDDEN);
			REQUIRE(CHN.put((pChar) "//http/connection/cap", p_tx_idx->p_block) == SERVICE_NO_ERROR);

			REQUIRE(CHN.connect.size() == 2);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/Estonia") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/Malaysia") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Kuala Lumpur") == 0);
			CHN.destroy_transaction(p_txn);

			strcpy((pChar) &p_tx_buf->p_block->tensor.cell_byte[0], "Tallinn");

			REQUIRE(CHN.put((pChar) "//http/cap/Estonia", p_tx_buf->p_block) == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/capitals/ESTONIA") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Tallinn") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.remove((pChar) "//http/capitals/ESTONIA") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//http/cap/Estonia") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/connection/capitals") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_INDEX);
			REQUIRE(p_txn->p_hea->index.size() == 1);
			REQUIRE(p_txn->p_hea->index["URL"] == "http://127.0.0.1:5000/test/capital/");
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.remove((pChar) "//http/connection/capitals") == SERVICE_NO_ERROR);

			REQUIRE(CHN.connect.size() == 1);

			REQUIRE(CHN.remove((pChar) "//http/connection/capitals") == SERVICE_ERROR_ENTITY_NOT_FOUND);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/France") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Paris") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/Japan") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/connection/cap") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_INDEX);
			REQUIRE(p_txn->p_hea->index.size() == 1);
			REQUIRE(p_txn->p_hea->index["URL"] == "http://127.0.0.1:5000/test/capital/");
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.remove((pChar) "//http/connection/cap") == SERVICE_NO_ERROR);

			REQUIRE(CHN.connect.size() == 0);
		}
		WHEN("We test forward_get()/forward_put()/forward_del()") {
			int ti = CHN.jazz_node_cluster_size++;

			CHN.jazz_node_name[ti] = "jzz_pybaby";
			CHN.jazz_node_port[ti] = 5000;
			CHN.jazz_node_ip  [ti] = "127.0.0.1";

			REQUIRE(CHN.forward_get(p_txn, (pChar) "jzz_pybaby", (pChar) "/test/str.blk") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->check_hash());
			compare_full_blocks(p_txn->p_block, p_tx_str->p_block);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.forward_get(p_txn, (pChar) "jzz_pybaby", (pChar) "/test/str.blah") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.forward_put((pChar) "jzz_pybaby", (pChar) "/test/str.blk", p_tx_tim->p_block) == SERVICE_NO_ERROR);
			REQUIRE(CHN.forward_put((pChar) "jzz_pybaby", (pChar) "/test/str.blah", p_tx_tim->p_block) == SERVICE_ERROR_BLOCK_NOT_FOUND);

			strcpy((pChar) &p_tx_buf->p_block->tensor.cell_byte[0], "Montevideo");

			REQUIRE(CHN.put((pChar) "//http/http://127.0.0.1:5000/test/capital/Uruguay", p_tx_buf->p_block) == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/http://127.0.0.1:5000/test/capital/Uruguay") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "Montevideo") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.forward_del((pChar) "jzz_pybaby", (pChar) "/test/capital/Uruguay") == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/http://127.0.0.1:5000/test/capital/Uruguay") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.forward_del((pChar) "jzz_pybaby", (pChar) "/test/capital/Uruguay") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.forward_del((pChar) "jzz_pybaby", (pChar) "///") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			CHN.jazz_node_name.erase(ti);
			CHN.jazz_node_port.erase(ti);
			CHN.jazz_node_ip.erase(ti);

			CHN.jazz_node_cluster_size--;
		}
		WHEN("We check all the non applicable") {
			StaticBlockHeader hea;
			Locator loc;

			REQUIRE(CHN.locate(loc, (pChar) "//http/anything/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/anything/pop", (pChar) "value") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//http/anything/pop") == SERVICE_ERROR_NOT_APPLICABLE);
			REQUIRE(CHN.header(hea,   (pChar) "//http/anything/pop") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.locate(loc, (pChar) "//http/anything/int") == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/anything/int", p_tx_rea->p_block) == SERVICE_ERROR_NOT_APPLICABLE);

			REQUIRE(CHN.header(p_txn, (pChar) "//http/anything/int") == SERVICE_ERROR_NOT_APPLICABLE);
			REQUIRE(CHN.header(hea,   (pChar) "//http/anything/int") == SERVICE_ERROR_NOT_APPLICABLE);
		}
		WHEN("We test copy") {
			REQUIRE(CHN.connect.size() == 0);

			REQUIRE(CHN.put((pChar) "//http/connection/cap", p_tx_idx->p_block) == SERVICE_NO_ERROR);

			REQUIRE(CHN.connect.size() == 1);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/UK") == SERVICE_ERROR_BLOCK_NOT_FOUND);
			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/England") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			strcpy((pChar) &p_tx_buf->p_block->tensor.cell_byte[0], "London");

			REQUIRE(CHN.put((pChar) "//http/cap/UK", p_tx_buf->p_block) == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/UK") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "London") == 0);
			CHN.destroy_transaction(p_txn);
			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/England") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.copy((pChar) "//http/cap/England", (pChar) "//http/cap/UK") == SERVICE_NO_ERROR);

			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/UK") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "London") == 0);
			CHN.destroy_transaction(p_txn);
			REQUIRE(CHN.get(p_txn, (pChar) "//http/cap/England") == SERVICE_NO_ERROR);
			REQUIRE(p_txn->p_block->cell_type == CELL_TYPE_BYTE);
			p_ret = (pChar) &p_txn->p_block->tensor.cell_byte[0];
			REQUIRE(strcmp(p_ret, "London") == 0);
			CHN.destroy_transaction(p_txn);

			REQUIRE(CHN.copy((pChar) "//http/cap/Holland", (pChar) "//http/cap/Netherlands") == SERVICE_ERROR_BLOCK_NOT_FOUND);

			REQUIRE(CHN.remove((pChar) "//http/cap/UK") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//http/cap/England") == SERVICE_NO_ERROR);
			REQUIRE(CHN.remove((pChar) "//http/connection/cap") == SERVICE_NO_ERROR);

			REQUIRE(CHN.connect.size() == 0);
		}
		WHEN("We test translate") {
			REQUIRE(CHN.translate((pTuple) p_tx_idx->p_block, (pChar) "//http/anything") == SERVICE_ERROR_WRONG_ARGUMENTS);
			REQUIRE(CHN.translate((pTuple) p_tx_xlt->p_block, (pChar) "//http/anything") == SERVICE_ERROR_WRONG_BASE);
		}
		CHN.destroy_transaction(p_tx_idx);
		CHN.destroy_transaction(p_tx_str);
		CHN.destroy_transaction(p_tx_rea);
		CHN.destroy_transaction(p_tx_tim);
		CHN.destroy_transaction(p_tx_xlt);
		CHN.destroy_transaction(p_tx_buf);
	}
	REQUIRE(CHN.alloc_bytes == CHN.max_transactions*sizeof(StoredTransaction));
	REQUIRE(CHN.p_buffer != nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.can_curl == 1);
	REQUIRE(CHN.can_zmq  == 1);
	REQUIRE(CHN.can_bash == 1);
	REQUIRE(CHN.file_lev == 3);

	REQUIRE(CHN.curl_ok == 1);
	REQUIRE(CHN.zmq_ok	== 1);

	REQUIRE(CHN.pipes.size()   == 0);
	REQUIRE(CHN.connect.size() == 0);

	REQUIRE(CHN.zmq_context != nullptr);

	REQUIRE(CHN.shut_down() == SERVICE_NO_ERROR);

	REQUIRE(CHN.alloc_bytes == 0);
	REQUIRE(CHN.p_buffer == nullptr);
	REQUIRE(CHN.p_free	 == nullptr);
	REQUIRE(CHN._lock_	 == 0);

	REQUIRE(CHN.curl_ok == 0);
	REQUIRE(CHN.zmq_ok	== 0);

	REQUIRE(CHN.zmq_context == nullptr);
}
